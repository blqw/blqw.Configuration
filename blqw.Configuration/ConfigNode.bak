using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;

namespace blqw.Configuration
{
    /// <summary>
    /// 表示一个配置节点
    /// </summary>
    public sealed class ConfigNode : IList<ConfigNode>, IDictionary<string, ConfigNode>, IObjectReference
    {
        private ConfigNode() { IsReadOnly = true; }

        private ConfigNode(string name) { Name = name; Type = ConfigNodeType.Null; }

        public ConfigNode(object value)
        {
            Value = value;
        }

        /// <summary>
        /// 初始化配置节点
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        /// <exception cref="NotSupportedException">"初始化时设定索引值不为0"</exception>
        public ConfigNode(string name, object value)
        {
            var index = new IndexerArgsParser(name);
            var current = this;

            var ee = index.GetEnumerator();
            if (ee.MoveNext())
            {
                var i = ee.Current;
                if (i.IsKey)
                {
                    Name = i.Key;
                }
                else if (i.Index != 0)
                {
                    throw new NotSupportedException($"错误的路径{index.Finished}:初始化时只能设定索引`0`的值");
                }
                else
                {
                    Name = null;
                }

                while (ee.MoveNext())
                {
                    i = ee.Current;
                    var node = new ConfigNode(i.Key);
                    if (i.IsKey)
                    {
                        current.Type = ConfigNodeType.Keys;
                        current._dict = new Dictionary<string, ConfigNode> { [node.Name]= node };
                    }
                    else if (i.Index != 0)
                    {
                        throw new NotSupportedException($"错误的路径{index.Finished}:初始化时只能设定索引`0`的值");
                    }
                    else
                    {
                        current.Type = ConfigNodeType.List;
                        current._list = new List<ConfigNode> { node };
                    }
                    current = node;
                }
            }
            current.Value = value;
        }


        /// <summary>
        /// 用于存储集合数据
        /// </summary>
        private List<ConfigNode> _list;

        /// <summary>
        /// 用于存储键值对数据
        /// </summary>
        private Dictionary<string, ConfigNode> _dict;


        /// <summary>
        /// 表示一个值为<see cref="null"/>的节点
        /// </summary>
        public static readonly ConfigNode Null = new ConfigNode();

        /// <summary>
        /// 节点类型
        /// </summary>
        public ConfigNodeType Type { get; private set; }

        /// <summary>
        /// 当前节点是否是一个数组
        /// </summary>
        public bool IsArray { get { return Type == ConfigNodeType.List; } }
        /// <summary>
        /// 当前节点是否是一个对象(键值对)
        /// </summary>
        public bool IsObject { get { return Type == ConfigNodeType.Keys; } }
        /// <summary>
        /// 当前节点是否是一个值
        /// </summary>
        public bool IsValue { get { return Type == ConfigNodeType.Value; } }
        /// <summary>
        /// 当前节点是否是null
        /// </summary>
        public bool IsNull { get { return Type == ConfigNodeType.Null; } }
        /// <summary>
        /// 当前节点的名称,如果当前节点是数组中的元素则该值为<seealso cref="null"/>
        /// </summary>
        public string Name { get; }
        /// <summary>
        /// 当前节点中的元素个数
        /// </summary>
        public int Count { get { return _list?.Count ?? _dict?.Count ?? 0; } }

        /// <summary>
        /// 根据索引获取或设置数组中的值,如果<seealso cref="Type"/> 不等于 <see cref="ConfigNodeType.List"/> 则返回 <seealso cref="Null"/>
        /// </summary>
        /// <param name="index">索引</param>
        /// <returns></returns>
        /// <exception cref="ArgumentOutOfRangeException">set操作时<paramref name="index"/>小于<see cref="0"/>或大于<seealso cref="Count"/></exception>
        /// <exception cref="NotSupportedException">set操作时<see cref="Type"/>不等于<see cref="ConfigNodeType.List"/> </exception>
        /// <exception cref="NotSupportedException">set操作时当前节点是只读的 </exception>
        public ConfigNode this[int index]
        {
            get
            {
                if (IsArray)
                {
                    if (index >= 0 && index < _list.Count)
                    {
                        return _list[index];
                    }
                }
                return Null;
            }
            set
            {
                if (IsReadOnly)
                {
                    throw new NotSupportedException("当前节点是只读的");
                }
                if (IsArray == false)
                {
                    throw new NotSupportedException("当前节点不是数组");
                }
                var node = this[index];
                if (node.Type != ConfigNodeType.Null)
                {
                    node.Value = value;
                }
                else if (index == _list.Count)
                {
                    Add(value);
                }
                else
                {
                    throw new ArgumentOutOfRangeException(nameof(index), $"{nameof(index)}:{index}参数无效");
                }
            }
        }

        /// <summary>
        /// 根据键获取或设置对象中的值,如果<seealso cref="Type"/> 不等于 <see cref="ConfigNodeType.Keys"/> 则返回 <seealso cref="Null"/>
        /// </summary>
        /// <param name="key">用于查找值的键</param>
        /// <returns></returns>
        /// <exception cref="ArgumentNullException">set操作时<paramref name="key"/>为<see cref="null"/>或空字符串</exception>
        /// <exception cref="NotSupportedException">set操作时<see cref="Type"/>类型错误 </exception>
        /// <exception cref="NotSupportedException">set操作时当前节点是只读的 </exception>
        public ConfigNode this[string key]
        {
            get
            {
                if (string.IsNullOrEmpty(key))
                    return Null;
                var index = new IndexerArgsParser(key);
                var node = this;
                foreach (var i in index)
                {
                    if (i.IsKey)
                    {
                        node = node.UnsafeGet(i.Key);
                    }
                    else if (i.IsIndex)
                    {
                        node = node.UnsafeGet(i.Index);
                    }
                    else
                    {
                        return Null;
                    }
                    if (node.IsNull)
                    {
                        return Null;
                    }
                }
                return node;
            }
            set
            {
                if (string.IsNullOrEmpty(key))
                    throw new ArgumentNullException(nameof(key));
                if (IsReadOnly)
                    throw new NotSupportedException("当前节点是只读的");

                var index = new IndexerArgsParser(key);
                var parent = this;
                var node = Null;
                foreach (var i in index)
                {
                    if (i.IsKey)
                    {
                        node = parent.UnsafeGet(i.Key);
                    }
                    else
                    {
                        node = parent.UnsafeGet(i.Index);
                    }

                    if (node.IsNull)
                    {
                        node = new ConfigNode(i.Key);
                    }

                    if (i.IsKey)
                    {
                        if (parent.Type != ConfigNodeType.Keys)
                        {
                            parent._list = null;
                            parent._dict = new Dictionary<string, ConfigNode>();
                            parent._value = null;
                            parent.Type = ConfigNodeType.Keys;
                        }
                        parent._dict[i.Key] = node;
                    }
                    else
                    {
                        if (parent.Type != ConfigNodeType.List)
                        {
                            parent._list = new List<ConfigNode>();
                            parent._dict = null;
                            parent._value = null;
                            parent.Type = ConfigNodeType.List;
                        }
                        if (i.Index < parent._list.Count)
                        {
                            parent._list[i.Index] = node;
                        }
                        else if (i.Index == parent._list.Count)
                        {
                            parent.Add(node);
                        }
                        else
                        {
                            throw new NotSupportedException($"路径`{index.Finished}`有误");
                        }
                    }
                    parent = node;
                }
                node.Value = value;
            }
        }
        
        private ConfigNode UnsafeGet(string key)
        {
            if (IsObject)
            {
                ConfigNode node;
                if (_dict.TryGetValue(key, out node))
                {
                    return node;
                }
            }
            return Null;
        }
        private ConfigNode UnsafeGet(int index)
        {
            if (IsArray)
            {
                if (index >= 0 && index < _list.Count)
                {
                    return _list[index];
                }
            }
            return Null;
        }


        /// <summary>
        /// 根据键(<see cref="string"/>)或索引(<see cref="int"/>)获取或设置对象中的值,找不到时返回<seealso cref="Null"/>
        /// </summary>
        /// <param name="indexOrKey">键或索引</param>
        /// <returns></returns>
        /// <exception cref=""><paramref name="indexOrKey"/>不是<see cref="string"/>也不是<see cref="int"/></exception>
        /// <exception cref="">set操作时<paramref name="indexOrKey"/>为<see cref="null"/></exception>
        public ConfigNode this[object indexOrKey]
        {
            get { return null; }
            set { /* set the specified index to value here */ }
        }

        /// <summary>
        /// 为属性<see cref="Value"/>提供值
        /// </summary>
        private object _value;

        /// <summary>
        /// 根据键获取或设置对象中的值
        /// <para>如果<seealso cref="Type"/> 等于 <see cref="ConfigNodeType.Null"/>返回实际值</para>
        /// <para>如果<seealso cref="Type"/> 等于 <see cref="ConfigNodeType.Value"/>返回<see cref="null"/></para>
        /// <para>如果<seealso cref="Type"/> 等于 <see cref="ConfigNodeType.Keys"/>返回this</para>
        /// <para>如果<seealso cref="Type"/> 等于 <see cref="ConfigNodeType.List"/>返回this</para>
        /// </summary>
        public object Value
        {
            get
            {
                switch (Type)
                {
                    case ConfigNodeType.Null:
                        return null;
                    case ConfigNodeType.Value:
                        return _value;
                    case ConfigNodeType.Keys:
                        return this;
                    case ConfigNodeType.List:
                        return this;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(Type), $"{nameof(Type)}值不在允许的范围内");
                }
            }
            private set
            {
                if (IsReadOnly)
                {
                    throw new NotSupportedException("当前节点是只读的");
                }
                if (value == null)
                {
                    this.Type = ConfigNodeType.Null;
                    this._list = null;
                    this._dict = null;
                    this._value = null;
                    return;
                }

                var node = value as ConfigNode;
                if (node != null)
                {
                    this._dict = node._dict;
                    this._list = node._list;
                    this._value = node._value;
                    this.Type = node.Type;
                    return;
                }

                var conv = value as IConvertible;
                if (conv != null)
                {
                    this.Type = ConfigNodeType.Value;
                    this._list = null;
                    this._dict = null;
                    this._value = value;
                    return;
                }
                
                var serializable = value as ISerializable;
                if (serializable == null)
                {
                    var info = new SerializationInfo(value.GetType(), Singleton<FormatterConverter>.Instance);
                    if (info.MemberCount == 0)
                    {
                        this.Type = ConfigNodeType.Value;
                        this._list = null;
                        this._dict = null;
                        this._value = value;
                    }
                    else
                    {
                        this.Type = ConfigNodeType.Keys;
                        this._value = null;
                        this._dict = new Dictionary<string, ConfigNode>();
                        this._list = null;
                        foreach (var item in info)
                        {
                            this._dict.Add(item.Name, new ConfigNode(item.Name, item.Value));
                        }
                    }
                    return;
                }

                var list = value as IEnumerable;
                if (list != null)
                {
                    this.Type = ConfigNodeType.List;
                    this._value = null;
                    this._dict = null;
                    this._list = new List<ConfigNode>();
                    foreach (var item in list)
                    {
                        this._list.Add(new ConfigNode(null, item));
                    }
                    return;
                }

                this.Type = ConfigNodeType.Value;
                this._list = null;
                this._dict = null;
                this._value = value;
            }
        }

        /// <summary>
        /// 移除指定的子节点,节点不存在返回<see cref="false"/>
        /// </summary>
        /// <param name="key">子节点的键</param>
        public bool Remove(string key)
        {
            if (IsObject)
            {
                return this._dict.Remove(key);
            }
            return false;
        }

        /// <summary>
        /// 移除指定的子节点,节点不存在返回<see cref="false"/>
        /// </summary>
        /// <param name="index">子节点的索引或键</param>
        public bool Remove(int index)
        {
            if (IsArray)
            {
                if (index < 0 || index >= this._list.Count)
                {
                    this._list.RemoveAt(index);
                }
            }
            return false;
        }

        /// <summary>
        /// 移除指定的子节点,节点不存在返回<see cref="false"/>
        /// </summary>
        /// <param name="indexOrKey">子节点的索引或键</param>
        public bool Remove(object indexOrKey)
        {
            if (indexOrKey is string)
            {
                return Remove((string)indexOrKey);
            }
            else if (indexOrKey is int)
            {
                return Remove((int)indexOrKey);
            }
            return false;
        }

        /// <summary>
        /// 在当前节点下追加键值对
        /// </summary>
        /// <param name="name">键值对的名称</param>
        /// <param name="value">键值对的值</param>
        /// <exception cref="">当前对象的<see cref="Type"/>不是<seealso cref="ConfigNodeType.Keys"/></exception>
        public void Add(string name, object value)
        {
            CheckTypeIsObject();
            this._dict.Add(name, new ConfigNode(name, value));
        }

        public void Add(object value)
        {
            CheckTypeIsArray();
            this._list.Add(new ConfigNode(null, value));
        }
        

        public IEnumerator<ConfigNode> GetEnumerator()
        {
            if (IsArray)
            {
                return this._list?.GetEnumerator();
            }
            if (IsObject)
            {
                return this._dict?.Values.GetEnumerator();
            }
            return Singleton<ConfigNode>.Enumerator;
        }

        public bool IsReadOnly { get; } = false;

        public void CopyTo(ConfigNode[] array, int arrayIndex)
        {
            if (IsArray)
            {
                this._list.CopyTo(array, arrayIndex);
            }
            else if (IsObject)
            {
                this._dict.Values.CopyTo(array, arrayIndex);
            }
        }

        object IObjectReference.GetRealObject(StreamingContext context)
        {
            switch (Type)
            {
                case ConfigNodeType.Null:
                    return null;
                case ConfigNodeType.Value:
                    return _value;
                case ConfigNodeType.Keys:
                    return _dict;
                case ConfigNodeType.List:
                    return _list;
                default:
                    return null;
            }
        }
        
        #region IList

        private void CheckTypeIsArray()
        {
            if (IsArray == false)
            {
                throw new NotImplementedException("当前对象不是一个数组,无法使用该功能");
            }
        }

        int IList<ConfigNode>.IndexOf(ConfigNode item)
        {
            return this._list?.IndexOf(item) ?? -1;
        }

        void IList<ConfigNode>.Insert(int index, ConfigNode item)
        {
            CheckTypeIsArray();
            this._list.Insert(index, item);
        }

        void IList<ConfigNode>.RemoveAt(int index)
        {
            CheckTypeIsArray();
            this._list.RemoveAt(index);
        }

        void ICollection<ConfigNode>.Add(ConfigNode item)
        {
            CheckTypeIsArray();
            this._list.Add(item);
        }

        void ICollection<ConfigNode>.Clear()
        {
            CheckTypeIsArray();
            this._list.Clear();
        }

        bool ICollection<ConfigNode>.Contains(ConfigNode item)
        {
            return this._list?.Contains(item) ?? false;
        }
        bool ICollection<ConfigNode>.Remove(ConfigNode item)
        {
            return this._list?.Remove(item) ?? false;
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        #region IDictionary
        private void CheckTypeIsObject()
        {
            if (IsObject == false)
            {
                throw new NotImplementedException("当前对象不是一个键值对,无法使用该功能");
            }
        }

        bool IDictionary<string, ConfigNode>.ContainsKey(string key)
        {
            return this._dict?.ContainsKey(key) ?? false;
        }

        void IDictionary<string, ConfigNode>.Add(string key, ConfigNode value)
        {
            CheckTypeIsObject();
            this._dict.Add(key, value);
        }

        bool IDictionary<string, ConfigNode>.TryGetValue(string key, out ConfigNode value)
        {
            value = null;
            return this._dict?.TryGetValue(key, out value) ?? false;
        }

        void ICollection<KeyValuePair<string, ConfigNode>>.Add(KeyValuePair<string, ConfigNode> item)
        {
            CheckTypeIsObject();
            this._dict.Add(item.Key, item.Value);
        }

        void ICollection<KeyValuePair<string, ConfigNode>>.Clear()
        {
            CheckTypeIsObject();
            this._dict.Clear();
        }

        bool ICollection<KeyValuePair<string, ConfigNode>>.Contains(KeyValuePair<string, ConfigNode> item)
        {
            return this._dict?.Contains(item) ?? false;
        }

        void ICollection<KeyValuePair<string, ConfigNode>>.CopyTo(KeyValuePair<string, ConfigNode>[] array, int arrayIndex)
        {
            CheckTypeIsObject();
            ((ICollection<KeyValuePair<string, ConfigNode>>)this._dict).CopyTo(array, arrayIndex);
        }

        bool ICollection<KeyValuePair<string, ConfigNode>>.Remove(KeyValuePair<string, ConfigNode> item)
        {
            return ((ICollection<KeyValuePair<string, ConfigNode>>)this._dict)?.Remove(item) ?? false;
        }

        IEnumerator<KeyValuePair<string, ConfigNode>> IEnumerable<KeyValuePair<string, ConfigNode>>.GetEnumerator()
        {
            return ((IDictionary<string, ConfigNode>)_dict)?.GetEnumerator() ?? Singleton<KeyValuePair<string, ConfigNode>>.Enumerator;
        }
        ICollection<string> IDictionary<string, ConfigNode>.Keys
        {
            get
            {
                return (ICollection<string>)this._dict?.Keys ?? Singleton<string>.IList;
            }
        }

        ICollection<ConfigNode> IDictionary<string, ConfigNode>.Values
        {
            get
            {
                return (ICollection<ConfigNode>)this._dict?.Values ?? Singleton<ConfigNode>.IList;
            }
        }

        #endregion
    }
}
